
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-10-10"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">ASSIGNMENT 2</a></li><li><a href="#2">QUESTION 1</a></li><li><a href="#3">QUESTION 2</a></li><li><a href="#4">QUESTION 3</a></li><li><a href="#5">QUESTION 4</a></li><li><a href="#6">QUESTION 5</a></li><li><a href="#7">QUESTION 6</a></li><li><a href="#8">QUESTION 7</a></li><li><a href="#9">QUESTION 8</a></li></ul></div><h2 id="1">ASSIGNMENT 2</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">
</span><span class="comment">Student data:
</span><span class="comment">    Name: Mauricio Vazquez Moran
</span><span class="comment">    Student number: 2821507
</span><span class="comment">%}</span>
</pre><h2 id="2">QUESTION 1</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">COMMENTS:
</span><span class="comment">    Check newton.m script
</span><span class="comment">%}</span>
</pre><h2 id="3">QUESTION 2</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">COMMENTS:
</span><span class="comment">    - I used the common MATLABS plot for this excercise. This allow me to
</span><span class="comment">    set of coordinates connected by line segments, specify X and Y
</span><span class="comment">    as vectors of the same length
</span><span class="comment">%}
</span>
<span class="comment">% Cleaning</span>
clear <span class="string">all</span>, close <span class="string">all</span>;

<span class="comment">% Define the function to aproximate a solution</span>
f = @(x)cosh(x)+cos(x)-3;

<span class="comment">% Define the derivative of the function</span>
df = @(x)sinh(x)-sin(x);

<span class="comment">% Define x0 or initial guess</span>
x0 = 3;

<span class="comment">% Define number of maximum iterations</span>
maxiter = 20;

<span class="comment">% Define error tolerance</span>
tol = eps;

<span class="comment">% Calling newton method function</span>
[x, iterates, residuals] = newton(f, df, x0, maxiter, tol);

<span class="comment">% Calculating order of convergence</span>
order_of_convergence = log(residuals(3:end) - x ./ residuals(2:end-1) - x ) ./ log(residuals(2:end-1) - x ./ residuals(1:end-2) - x);

<span class="comment">%{
</span><span class="comment">ORDER OF CONVERGENCE:
</span><span class="comment">     As result we get vector containing the estimated order of convergence
</span><span class="comment">     for each iteration after the first two iterations.
</span><span class="comment">%}
</span>
<span class="comment">% Plot residuals</span>
figure;
plot(1:length(residuals), residuals, <span class="string">'square-'</span>, <span class="string">'LineWidth'</span>, 1);

<span class="comment">% Adding tittle</span>
title(<span class="string">'Residuals vs. Number of iterations'</span>);

<span class="comment">% Adding labels</span>
xlabel(<span class="string">'Number of iterations'</span>);
ylabel(<span class="string">'Residuals'</span>);

<span class="comment">% Adding grid</span>
grid <span class="string">on</span>;

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Estimated root: x = %.6f\n'</span>, x);
fprintf(<span class="string">'Order of Convergence: %.4f\n'</span>, order_of_convergence(end));

<span class="comment">% Displaying additional comments</span>
fprintf([<span class="string">'Additional comments: It can be seen in the graph that the magnitude '</span> <span class="keyword">...</span>
    <span class="string">'of the residuals, in this exercise, falls rapidly as the iterations '</span> <span class="keyword">...</span>
    <span class="string">'increase. Thus, by the fifth iteration, the residual has practically '</span> <span class="keyword">...</span>
    <span class="string">'converged to zero. \n'</span>])
</pre><pre class="codeoutput">Estimated root: x = 1.857921
Order of Convergence: 1.9884
Additional comments: It can be seen in the graph that the magnitude of the residuals, in this exercise, falls rapidly as the iterations increase. Thus, by the fifth iteration, the residual has practically converged to zero. 
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <h2 id="4">QUESTION 3</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">COMMENTS:
</span><span class="comment">    - I used the common MATLABS plot for this excercise. This allow me to
</span><span class="comment">    set of coordinates connected by line segments, specify X and Y
</span><span class="comment">    as vectors of the same length
</span><span class="comment">%}
</span>
<span class="comment">% Cleaning</span>
clear <span class="string">all</span>, close <span class="string">all</span>;

<span class="comment">% Define the function to aproximate a solution</span>
f = @(x) cosh(x) + cos(x) - 2;

<span class="comment">% Define the derivative of the function</span>
df = @(x) sinh(x) - sin(x);

<span class="comment">% Define x0 or initial guess</span>
x0 = 3;

<span class="comment">% Define number of maximum iterations</span>
maxiter = 20;

<span class="comment">% Define error tolerance</span>
tol = eps;

<span class="comment">% Calling newton method function</span>
[x, iterates, residuals] = newton(f, df, x0, maxiter, tol);

<span class="comment">% Calculate order of convergence</span>
order_of_convergence = log(residuals(3:end) - x ./ residuals(2:end-1) - x ) ./ log(residuals(2:end-1) - x ./ residuals(1:end-2) - x);

<span class="comment">%{
</span><span class="comment">ORDER OF CONVERGENCE:
</span><span class="comment">     As result we get vector containing the estimated order of convergence
</span><span class="comment">     for each iteration after the first two iterations.
</span><span class="comment">%}
</span>
<span class="comment">% Plot residuals</span>
figure;
plot(1:length(residuals), residuals, <span class="string">'square-'</span>, <span class="string">'LineWidth'</span>, 1);

<span class="comment">% Adding tittle</span>
title(<span class="string">'Residuals vs. Number of iterations'</span>);

<span class="comment">% Adding labels</span>
xlabel(<span class="string">'Number of iterations'</span>);
ylabel(<span class="string">'Residuals'</span>);

<span class="comment">% Adding grid</span>
grid <span class="string">on</span>;

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Estimated root: x = %.6f\n'</span>, x);
fprintf(<span class="string">'Order of Convergence: %.4f\n'</span>, order_of_convergence(end));

<span class="comment">% Displaying additional comments</span>
fprintf([<span class="string">'Additional comments: It can be seen in the graph that the magnitude '</span> <span class="keyword">...</span>
    <span class="string">'of the residuals, in this exercise, falls rapidly as the iterations '</span> <span class="keyword">...</span>
    <span class="string">'increase. Thus, by the eighth iteration, the residual has practically '</span> <span class="keyword">...</span>
    <span class="string">'converged to zero. \n'</span>])
</pre><pre class="codeoutput">Estimated root: x = 0.009730
Order of Convergence: 1.0778
Additional comments: It can be seen in the graph that the magnitude of the residuals, in this exercise, falls rapidly as the iterations increase. Thus, by the eighth iteration, the residual has practically converged to zero. 
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="5">QUESTION 4</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">COMMENTS:
</span><span class="comment">    Check Wp.m script and Wm.m script
</span><span class="comment">%}</span>
</pre><h2 id="6">QUESTION 5</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">    COMMENTS:
</span><span class="comment">        I am going to divide this section into 3 parts:
</span><span class="comment">            1) Show Wp error
</span><span class="comment">            2) Show Wm error
</span><span class="comment">            3) Plot the functions
</span><span class="comment">%}
</span>
<span class="comment">%{
</span><span class="comment">    Part 1: Show Wp error
</span><span class="comment">        By hypothesis (Wikipedia link provided) we get:
</span><span class="comment">            y = Wp(x) if x &gt;= 0.
</span><span class="comment">        So to show the error, we would need to pass an argument that is
</span><span class="comment">        magnitude is less tan zero.
</span><span class="comment">
</span><span class="comment">        I used a try and catch block to attempt to call the functions
</span><span class="comment">        with the invalid input.
</span><span class="comment">%}
</span>
<span class="comment">% Test Wp with an invalid input</span>
<span class="comment">% Defining an input smaller than zero</span>
x_inv = - 0.1;

<span class="keyword">try</span>

    <span class="comment">% Evaluating in function</span>
    r_inv = Wp(x_inv);

    <span class="comment">% Displaying if its valid</span>
    <span class="comment">% fprintf('Wp(%f) = %f\n', x_inv, r_inv);</span>

<span class="keyword">catch</span>

    <span class="comment">% Displaying if is invalid</span>
    fprintf(<span class="string">'Error!!! Wp(%f) is invalid.\n'</span>, x_inv);

<span class="keyword">end</span>

<span class="comment">%{
</span><span class="comment">    Part 2: Show Wm error
</span><span class="comment">        By hypothesis (Wikipedia link provided) we get:
</span><span class="comment">            y = Wm(x) if -(1/e) =&lt; x &lt;0.
</span><span class="comment">        So to show the error, we would need to pass an argument that is
</span><span class="comment">        magnitude is ou of this interval.
</span><span class="comment">
</span><span class="comment">        I used a try and catch block to attempt to call the functions
</span><span class="comment">        with the invalid input.
</span><span class="comment">%}
</span>
<span class="comment">% Test Wp with an invalid input</span>
<span class="comment">% Defining an input smaller than zero</span>
x_inv = - (1/exp(1)) - 0.1;

<span class="keyword">try</span>

    <span class="comment">% Evaluating in function</span>
    r_inv = Wm(x_inv);

    <span class="comment">% Displaying if its valid</span>
    <span class="comment">% fprintf('Wm(%f) = %f\n', x_inv, r_inv);</span>

<span class="keyword">catch</span>

    <span class="comment">% Displaying if is invalid</span>
    fprintf(<span class="string">'Error!!! Wm(%f) is invalid.\n'</span>, x_inv);

<span class="keyword">end</span>

<span class="comment">%{
</span><span class="comment">    Part 3: Plotting functions
</span><span class="comment">        Using blue for the graph of Wp and magenta for the graph of Wm.
</span><span class="comment">%}
</span>
<span class="comment">% Cleaning</span>
clear <span class="string">all</span>, close <span class="string">all</span>;

<span class="comment">% Definining a range of x-values</span>
x = linspace(-(1/exp(1)), 3, 1000);

<span class="comment">% Initializing arrays to store y-values</span>
y1 = zeros(size(x));
y2 = zeros(size(x));

<span class="comment">% Calculate the corresponding y-values using the Lambert W functions</span>
<span class="keyword">for</span> i = 1:length(x)

    <span class="comment">% By source provided, this is will be valuating in Wm</span>
    <span class="keyword">if</span> -(1/exp(1)) &lt;= x(i) &amp;&amp; x(i) &lt; 0

        <span class="comment">% Other branch time to evaluate (Wm)</span>
        y2(i) = Wm(x(i));

        <span class="comment">% Placeholder for values outside the domain of Wm</span>
        y1(i) = NaN;

    <span class="keyword">else</span>

        <span class="comment">% Principal branch time to evaluate (Wp)</span>
        y1(i) = Wp(x(i));

        <span class="comment">% Other branch (Wm)</span>
        y2(i) = NaN;

    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">% Creating the plot</span>
figure;
plot(x, y1, <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 2);
hold <span class="string">on</span>;
plot(x, y2, <span class="string">'m'</span>, <span class="string">'LineWidth'</span>, 2);

<span class="comment">% Adding label names</span>
xlabel(<span class="string">'x'</span>);
ylabel(<span class="string">'y'</span>);

<span class="comment">% Adding title name</span>
title(<span class="string">'Lambert W Branches'</span>);
legend(<span class="string">'Wp'</span>, <span class="string">'Wm'</span>);
grid <span class="string">on</span>;
hold <span class="string">off</span>;

<span class="comment">% Displaying additional comments</span>
fprintf([<span class="string">'Additional comments: In the graph, you can clearly see the '</span> <span class="keyword">...</span>
    <span class="string">'branching of the Lambert function. On the one hand, the magenta color '</span> <span class="keyword">...</span>
    <span class="string">'allows us to see how the function comes from -1/e until it hits zero '</span> <span class="keyword">...</span>
    <span class="string">'through the non-main branch. After that, the main branch resumes '</span> <span class="keyword">...</span>
    <span class="string">'(blue color) for all values greater than zero. \n'</span>])
</pre><pre class="codeoutput">By hypothesis, no possible to obtain Wp or W0 because -1.000000e-01 is not &gt;= 0.
Error!!! Wp(-0.100000) is invalid.
By hypothesis, no possible to obtain Wm because -4.678794e-01 is not  &gt;= (-1/e) and &lt; 0.
Error!!! Wm(-0.467879) is invalid.
Additional comments: In the graph, you can clearly see the branching of the Lambert function. On the one hand, the magenta color allows us to see how the function comes from -1/e until it hits zero through the non-main branch. After that, the main branch resumes (blue color) for all values greater than zero. 
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <h2 id="7">QUESTION 6</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">    Part a) Using MATLAB function 'roots':
</span><span class="comment">    The roots function solves polynomial equations of the form:
</span><span class="comment">        p1(x^n) +...+ pn(x) + pn+1=0.
</span><span class="comment">    Polynomial equations contain a single variable with nonnegative
</span><span class="comment">    exponents.
</span><span class="comment">%}
</span>
<span class="comment">% Defining coefficients on the necessary format the function needs</span>
coef = [0.01, 1000, 0.01];

<span class="comment">% Using the MATLAB function</span>
roots_r1 = roots(coef);

<span class="comment">% Selection the largest root approximation</span>
r1 = max(roots_r1);

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Estimated root for r1: x = %.15f\n'</span>, r1);

<span class="comment">%{
</span><span class="comment">    Part b) Using Newton Method:
</span><span class="comment">    Newton's method sucess depends on the initial choice of x0 and may not
</span><span class="comment">    converge if the initial guess is far from the root.
</span><span class="comment">%}
</span>
<span class="comment">% Defining the given polynomial function and its derivative</span>
f = @(x) 0.01*x.^2 + 1000*x + 0.01;
df = @(x) 0.02*x + 1000;

<span class="comment">% Initial guess, given the first result</span>
x0 = 0.0001;

<span class="comment">% Given by hypothesis, defining tolerance</span>
tol = eps;

<span class="comment">% Given by some last excercise, defining iterations</span>
maxiter = 20;

<span class="comment">% Call the newton function to find the root</span>
[r2, ~, ~] = newton(f, df, x0, maxiter, tol);

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Estimated root for r2: x = %.15f\n'</span>, r2);

<span class="comment">%{
</span><span class="comment">    Part c) Using quadratic formula:
</span><span class="comment">    The quadratic formula helps us solve any quadratic equation. First,
</span><span class="comment">    we bring the equation to the form ax&sup2; + bx + c=0, where a, b, and c are
</span><span class="comment">    coefficients. Then, we plug these coefficients in the formula:
</span><span class="comment">        (-b&plusmn;&#8730;(b&sup2;-4ac))/(2a)
</span><span class="comment">%}
</span>
<span class="comment">% Defining coefficients</span>
a = 0.01;
b = 1000;
c = 0.01;

<span class="comment">% By formula, defining discriminant</span>
discriminant = b^2 - 4*a*c;

<span class="comment">% Obtaining root</span>
r3 = (-b + sqrt(discriminant)) / (2*a);

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Estimated root for r3: x = %.15f\n'</span>, r3);

<span class="comment">%{
</span><span class="comment">    Part d) Commenting results.
</span><span class="comment">%}
</span>
<span class="comment">% Displaying comments</span>
fprintf([<span class="string">'Additional comments: First of all, in order to observe the change '</span> <span class="keyword">...</span>
    <span class="string">'between using one method or the other, we have to display the answer '</span> <span class="keyword">...</span>
    <span class="string">'to approximately 15 decimal places. By observing and analyzing the '</span> <span class="keyword">...</span>
    <span class="string">'result, we can see that both the use of the Matlab function "roots" '</span> <span class="keyword">...</span>
    <span class="string">'and the use of Newtons method have an identical magnitude when '</span> <span class="keyword">...</span>
    <span class="string">'displayed to 15 decimal places. This shows the accuracy of Newtons '</span> <span class="keyword">...</span>
    <span class="string">'algorithm for finding roots. On the other hand, we can see that when '</span> <span class="keyword">...</span>
    <span class="string">'using the quadratic formula, the result changes by several decimal '</span> <span class="keyword">...</span>
    <span class="string">'places. In other words, it is not as accurate as the first two methods '</span> <span class="keyword">...</span>
    <span class="string">'used in this exercise. \n'</span>]);
</pre><pre class="codeoutput">Estimated root for r1: x = -0.000010000000001
Estimated root for r2: x = -0.000010000000001
Estimated root for r3: x = -0.000010000002248
Additional comments: First of all, in order to observe the change between using one method or the other, we have to display the answer to approximately 15 decimal places. By observing and analyzing the result, we can see that both the use of the Matlab function "roots" and the use of Newtons method have an identical magnitude when displayed to 15 decimal places. This shows the accuracy of Newtons algorithm for finding roots. On the other hand, we can see that when using the quadratic formula, the result changes by several decimal places. In other words, it is not as accurate as the first two methods used in this exercise. 
</pre><h2 id="8">QUESTION 7</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">    COMMENTS:
</span><span class="comment">        - The constraint may be the equation that describes the boundary
</span><span class="comment">        of a region or it may not be.
</span><span class="comment">        - Need to be careful with the fact that in some cases minimums and
</span><span class="comment">        maximums won't exist even though the method will seem to imply
</span><span class="comment">        that they do.
</span><span class="comment">%}
</span>
<span class="comment">%{
</span><span class="comment">    EXCERCISE DIVISION:
</span><span class="comment">        Part a) Finding minimum and maximum
</span><span class="comment">        Part b) Checking graphically that its correct
</span><span class="comment">%}
</span>
<span class="comment">%{
</span><span class="comment">    PART A) Finding minimum and maximum
</span><span class="comment">%}
</span>
<span class="comment">% Cleaning</span>
clear <span class="string">all</span>, close <span class="string">all</span>;

<span class="comment">% Defining the Lagrangian function</span>
L = @(x) x(1).^3 + x(2).^3 + 3*x(1)*x(1) + x(3)*((x(1) - 3).^2 + (x(2) - 3).^2 - 9);

<span class="comment">% Defining Lagrange multipliers system</span>
f = @(x) [3*x(1).^2 + 3*x(2) + 2*x(3)*(x(1) - 3), 3*x(2).^2 + 3*x(1) + 2*x(3)*(x(2) - 3), (x(1) - 3).^2 + (x(2) - 3).^2 - 9];

<span class="comment">% Defining equations derivatives</span>
df = @(x) [6*x(1) + 2*x(3), 3, 2*(x(1) - 3); 3, 6*x(2) + 2*x(3), 2*(x(2) - 3); 2*(x(1) - 3), 2*(x(2) - 3), 0];

<span class="comment">% Defining initial guess</span>
init_guess = [0; 0; 0];

<span class="comment">% Defining maximum number of iterations</span>
maxiter = 100;

<span class="comment">% Defining tolerance</span>
tol = eps;

<span class="comment">% Newton function for the critical points</span>
[x_crit, ~, ~] = newton(f, df, init_guess, maxiter, tol);

<span class="comment">% Displaying critical points</span>
fprintf(<span class="string">'Critical point: [ x = %.5f , y = %.5f ] \n'</span>, x_crit(1), x_crit(2));

<span class="comment">% Evaluating the objective function on critical point</span>
xtrem_val = x_crit(1).^3 + x_crit(2).^3 + 3 * x_crit(1) * x_crit(2);

<span class="comment">% Displaying extreme value</span>
fprintf(<span class="string">'Extreme Value: %.5f \n'</span>, xtrem_val)

<span class="comment">%{
</span><span class="comment">    PART B) Checking graphically that is correct
</span><span class="comment">%}
</span>
<span class="comment">% Defining plot</span>
figure;

<span class="comment">% Defining a range of x-values</span>
x1 = -4:0.4:4;

<span class="comment">% Defining a range of y-values equal to x-values</span>
y1 = x1;

<span class="comment">% Meshgrid fos the matrix needed fot plotting</span>
[X1,Y1] = meshgrid(x1);

<span class="comment">% Calculating the corresponding z-values of F(x,y)</span>
Z1 = X1.^3 + Y1.^3 + 3*X1.*Y1;

<span class="comment">% Creating a 3D-plot of F</span>
meshz(Z1);

<span class="comment">%{
</span><span class="comment">    Adding constraint figure
</span><span class="comment">%}
</span>
<span class="comment">% Defining a range of x-values</span>
x2 = 0:0.50:7;

<span class="comment">% Defining a range of y-values equal to x-values</span>
y2 = x2;

<span class="comment">% Calculating the corresponding z-values of F(x,y)</span>
z2 = (x2 - 3).^2 - (y2 - 3).^2 - 9;

<span class="comment">% Adding a 3D-plot of the constraint</span>
hold <span class="string">on</span>;
plot3(x2, y2, z2,<span class="string">'-o'</span>, <span class="string">'Color'</span>, <span class="string">'r'</span>);

<span class="comment">% Labeling the axes</span>
xlabel(<span class="string">'x'</span>);
ylabel(<span class="string">'y'</span>);
zlabel(<span class="string">'z'</span>);

<span class="comment">% Adding colorbar</span>
colorbar;

<span class="comment">% Adding a title</span>
title(<span class="string">'Plot of F(x, y) with constraint'</span>);

<span class="comment">% Adding grig to the figure</span>
grid <span class="string">on</span>;

<span class="comment">%{
</span><span class="comment">    Adding critical point
</span><span class="comment">%}
</span>
<span class="comment">% Plot the critical point</span>
scatter3(x_crit(1), x_crit(2), xtrem_val, <span class="string">'Marker'</span>, <span class="string">'o'</span>, <span class="string">'Color'</span>, <span class="string">'g'</span>, <span class="string">'LineWidth'</span>, 2);

<span class="comment">% Adding legend</span>
legend(<span class="string">'F(x, y)'</span>, <span class="string">'constraint'</span>, <span class="string">'Critical point'</span>);

<span class="comment">% Displaying comments</span>
fprintf([<span class="string">'The results obtained and the results observed in the graph seem '</span> <span class="keyword">...</span>
    <span class="string">'correct. It was a great learning experience to observe how '</span> <span class="keyword">...</span>
    <span class="string">'using a method to find roots, such as Newtons method, of a certain '</span> <span class="keyword">...</span>
    <span class="string">'function, can be used to find critical points. One disadvantage, '</span> <span class="keyword">...</span>
    <span class="string">'which I realized in this excercise, is that a near local maxima or '</span> <span class="keyword">...</span>
    <span class="string">'local minima, due to oscillation, may cause to a slow '</span> <span class="keyword">...</span>
    <span class="string">'convergence.\n'</span>]);
</pre><pre class="codeoutput">Critical point: [ x = 0.87868 , y = 0.87868 ] 
Extreme Value: 3.67305 
The results obtained and the results observed in the graph seem correct. It was a great learning experience to observe how using a method to find roots, such as Newtons method, of a certain function, can be used to find critical points. One disadvantage, which I realized in this excercise, is that a near local maxima or local minima, due to oscillation, may cause to a slow convergence.
</pre><img vspace="5" hspace="5" src="main_04.png" alt=""> <h2 id="9">QUESTION 8</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">    COMMENTS:
</span><span class="comment">        - Fast convergence: It converges fast, if it converges. Which
</span><span class="comment">        means, in most cases we get root (answer) in less number of steps.
</span><span class="comment">        - It requires only one guess.
</span><span class="comment">        - Derivation is more intuitive, which means it is easier to
</span><span class="comment">        understand its behaviour, when it is likely to converge and when
</span><span class="comment">        it is likely to diverge.
</span><span class="comment">
</span><span class="comment">%}
</span>
<span class="comment">%{
</span><span class="comment">    EXCERCISE DIVISION:
</span><span class="comment">        Part a) Calculating
</span><span class="comment">        Part b) Plotting
</span><span class="comment">%}
</span>
<span class="comment">%{
</span><span class="comment">    PART A) Calculating
</span><span class="comment">%}
</span>
<span class="comment">% Cleaning</span>
clear <span class="string">all</span>, close <span class="string">all</span>;

<span class="comment">% Defining the function g(x)</span>
g = @(x) 4*x - 4*x.^2;

<span class="comment">% Generating 1000 uniformly spaced in the interval [-0.1, 1]</span>
interval = linspace(-0.1, 1, 1000);

<span class="comment">% Defining number of maxmum iterations</span>
max_iterations = 100;

<span class="comment">% Defining tolerance</span>
tol = 1e-6;

<span class="comment">% Initializing array to store roots</span>
con_roots = zeros(1000, 1);

<span class="comment">% Defining the roots values</span>
r1 = 0.45;
r2 = 0.65;
r3 = 0.3;
r4 = 0.9;

<span class="comment">% Defining r^ array</span>
roots = [r1, r2, r3, r4];

<span class="comment">% Creating arrays to store legend entries</span>
ent = cell(length(roots), 1);

<span class="comment">% Creating arrays to store legend handles</span>
hand = zeros(length(roots), 1);

<span class="comment">% Iterating points</span>
<span class="keyword">for</span> i = 1:1000
    x0 = interval(i);

    <span class="comment">% Applying Newton's method at each point</span>
    [x, iterates, residuals] = newton(@(x)g(x) - x0, @(x) 4 - 8 * x, x0, max_iterations, tol);

    <span class="comment">% Checking convergence</span>
    <span class="keyword">if</span> abs(g(x) - x0) &lt; tol

        <span class="comment">% Determining root that converged</span>
        [~, index] = min(abs(x - roots));
        con_roots(i) = index;

    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">%{
</span><span class="comment">    PART B) Plotting
</span><span class="comment">%}
</span>
<span class="comment">% Creating colormap array</span>
colors = [<span class="string">'g'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'y'</span>];

<span class="comment">% Ploting</span>
<span class="keyword">for</span> i = 1:1000
    <span class="keyword">if</span> con_roots(i) &gt; 0

        <span class="comment">% Ploting each interval point</span>
        plot(interval(i), 0, <span class="string">'.'</span>, <span class="string">'Color'</span>, colors(con_roots(i)));
        hold <span class="string">on</span>;

    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">% Customizing plot</span>
<span class="comment">% Customizing x-label</span>
xlabel(<span class="string">'Interval [ -0.1, 1]'</span>);

<span class="comment">% Customizing y-label</span>
ylabel(<span class="string">'Number of Iterations'</span>);

<span class="comment">% Adding title</span>
title([<span class="string">'Convergence of the 1000 uniformly spaced points on the interval '</span> <span class="keyword">...</span>
    <span class="string">'[-0.1, 1] with Newtons Method'</span>]);

<span class="comment">% Updating legend entries and handles</span>
<span class="keyword">for</span> i = 1:length(roots)

    <span class="comment">% Displaying legend entries</span>
    ent{i} = sprintf(<span class="string">'Root %d'</span>, i);

    <span class="comment">% Plotting legend handles</span>
    hand(i) = plot(NaN, NaN, <span class="string">'o'</span>, <span class="string">'Color'</span>, colors(i)); <span class="comment">% Create empty plot for legend</span>

<span class="keyword">end</span>

<span class="comment">% Creating the legend</span>
legend(hand, ent);

<span class="comment">% Putting grid</span>
grid <span class="string">on</span>;

<span class="comment">% Displaying results</span>
fprintf(<span class="string">'Counts of points converging to each root:\n'</span>);

<span class="comment">% Displaying for each root</span>
<span class="keyword">for</span> i = 1:length(roots)

    <span class="comment">% Displaying each x amount of points converged to root x</span>
    fprintf(<span class="string">'Root %d: %d points\n'</span>, i, sum(con_roots == i));

<span class="keyword">end</span>

<span class="comment">% Displaying comments</span>
fprintf([<span class="string">'Newtons method always converges to the root nearest the initial '</span> <span class="keyword">...</span>
    <span class="string">'condition: From the plot, we can observe that this claim is generally '</span> <span class="keyword">...</span>
    <span class="string">'true. Points tend to converge to the root nearest their initial '</span> <span class="keyword">...</span>
    <span class="string">'condition.\n'</span>]);
fprintf([<span class="string">'Each of the four roots attracts the same number of '</span> <span class="keyword">...</span>
    <span class="string">'iterations.\n'</span>]);
</pre><pre class="codeoutput">Counts of points converging to each root:
Root 1: 10 points
Root 2: 265 points
Root 3: 545 points
Root 4: 180 points
Newtons method always converges to the root nearest the initial condition: From the plot, we can observe that this claim is generally true. Points tend to converge to the root nearest their initial condition.
Each of the four roots attracts the same number of iterations.
</pre><img vspace="5" hspace="5" src="main_05.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ASSIGNMENT 2

%{

Student data: 
    Name: Mauricio Vazquez Moran
    Student number: 2821507
%}

%% QUESTION 1

%{ 
COMMENTS: 
    Check newton.m script 
%}

%% QUESTION 2

%{ 
COMMENTS: 
    - I used the common MATLABS plot for this excercise. This allow me to 
    set of coordinates connected by line segments, specify X and Y 
    as vectors of the same length
%}

% Cleaning
clear all, close all;

% Define the function to aproximate a solution
f = @(x)cosh(x)+cos(x)-3;

% Define the derivative of the function
df = @(x)sinh(x)-sin(x);

% Define x0 or initial guess
x0 = 3;

% Define number of maximum iterations
maxiter = 20;

% Define error tolerance
tol = eps;

% Calling newton method function
[x, iterates, residuals] = newton(f, df, x0, maxiter, tol);

% Calculating order of convergence
order_of_convergence = log(residuals(3:end) - x ./ residuals(2:end-1) - x ) ./ log(residuals(2:end-1) - x ./ residuals(1:end-2) - x);

%{
ORDER OF CONVERGENCE:
     As result we get vector containing the estimated order of convergence 
     for each iteration after the first two iterations.
%}

% Plot residuals
figure;
plot(1:length(residuals), residuals, 'square-', 'LineWidth', 1);

% Adding tittle
title('Residuals vs. Number of iterations');

% Adding labels
xlabel('Number of iterations');
ylabel('Residuals');

% Adding grid
grid on;

% Displaying results
fprintf('Estimated root: x = %.6f\n', x);
fprintf('Order of Convergence: %.4f\n', order_of_convergence(end));

% Displaying additional comments
fprintf(['Additional comments: It can be seen in the graph that the magnitude ' ...
    'of the residuals, in this exercise, falls rapidly as the iterations ' ...
    'increase. Thus, by the fifth iteration, the residual has practically ' ...
    'converged to zero. \n'])

%% QUESTION 3

%{ 
COMMENTS: 
    - I used the common MATLABS plot for this excercise. This allow me to 
    set of coordinates connected by line segments, specify X and Y 
    as vectors of the same length
%}

% Cleaning
clear all, close all;

% Define the function to aproximate a solution
f = @(x) cosh(x) + cos(x) - 2;

% Define the derivative of the function
df = @(x) sinh(x) - sin(x);

% Define x0 or initial guess
x0 = 3;

% Define number of maximum iterations
maxiter = 20;

% Define error tolerance
tol = eps;

% Calling newton method function
[x, iterates, residuals] = newton(f, df, x0, maxiter, tol);

% Calculate order of convergence
order_of_convergence = log(residuals(3:end) - x ./ residuals(2:end-1) - x ) ./ log(residuals(2:end-1) - x ./ residuals(1:end-2) - x);

%{
ORDER OF CONVERGENCE:
     As result we get vector containing the estimated order of convergence 
     for each iteration after the first two iterations.
%}

% Plot residuals
figure;
plot(1:length(residuals), residuals, 'square-', 'LineWidth', 1);

% Adding tittle
title('Residuals vs. Number of iterations');

% Adding labels
xlabel('Number of iterations');
ylabel('Residuals');

% Adding grid
grid on;

% Displaying results
fprintf('Estimated root: x = %.6f\n', x);
fprintf('Order of Convergence: %.4f\n', order_of_convergence(end));

% Displaying additional comments
fprintf(['Additional comments: It can be seen in the graph that the magnitude ' ...
    'of the residuals, in this exercise, falls rapidly as the iterations ' ...
    'increase. Thus, by the eighth iteration, the residual has practically ' ...
    'converged to zero. \n'])

%% QUESTION 4

%{
COMMENTS: 
    Check Wp.m script and Wm.m script 
%}

%% QUESTION 5

%{
    COMMENTS: 
        I am going to divide this section into 3 parts:
            1) Show Wp error 
            2) Show Wm error
            3) Plot the functions
%}

%{
    Part 1: Show Wp error
        By hypothesis (Wikipedia link provided) we get:
            y = Wp(x) if x >= 0.
        So to show the error, we would need to pass an argument that is
        magnitude is less tan zero.

        I used a try and catch block to attempt to call the functions 
        with the invalid input. 
%}

% Test Wp with an invalid input
% Defining an input smaller than zero
x_inv = - 0.1;

try

    % Evaluating in function
    r_inv = Wp(x_inv);
    
    % Displaying if its valid
    % fprintf('Wp(%f) = %f\n', x_inv, r_inv);

catch
    
    % Displaying if is invalid
    fprintf('Error!!! Wp(%f) is invalid.\n', x_inv);

end

%{
    Part 2: Show Wm error
        By hypothesis (Wikipedia link provided) we get:
            y = Wm(x) if -(1/e) =< x <0.
        So to show the error, we would need to pass an argument that is
        magnitude is ou of this interval.

        I used a try and catch block to attempt to call the functions 
        with the invalid input. 
%}

% Test Wp with an invalid input
% Defining an input smaller than zero
x_inv = - (1/exp(1)) - 0.1;

try

    % Evaluating in function
    r_inv = Wm(x_inv);
    
    % Displaying if its valid
    % fprintf('Wm(%f) = %f\n', x_inv, r_inv);

catch
    
    % Displaying if is invalid
    fprintf('Error!!! Wm(%f) is invalid.\n', x_inv);

end

%{
    Part 3: Plotting functions
        Using blue for the graph of Wp and magenta for the graph of Wm.
%}

% Cleaning
clear all, close all;

% Definining a range of x-values
x = linspace(-(1/exp(1)), 3, 1000);

% Initializing arrays to store y-values
y1 = zeros(size(x));
y2 = zeros(size(x));

% Calculate the corresponding y-values using the Lambert W functions
for i = 1:length(x)

    % By source provided, this is will be valuating in Wm
    if -(1/exp(1)) <= x(i) && x(i) < 0

        % Other branch time to evaluate (Wm)
        y2(i) = Wm(x(i));

        % Placeholder for values outside the domain of Wm
        y1(i) = NaN; 

    else
        
        % Principal branch time to evaluate (Wp)
        y1(i) = Wp(x(i));

        % Other branch (Wm)
        y2(i) = NaN; 

    end

end

% Creating the plot
figure;
plot(x, y1, 'b', 'LineWidth', 2);
hold on;
plot(x, y2, 'm', 'LineWidth', 2);

% Adding label names
xlabel('x');
ylabel('y');

% Adding title name
title('Lambert W Branches');
legend('Wp', 'Wm');
grid on;
hold off;

% Displaying additional comments
fprintf(['Additional comments: In the graph, you can clearly see the ' ...
    'branching of the Lambert function. On the one hand, the magenta color ' ...
    'allows us to see how the function comes from -1/e until it hits zero ' ...
    'through the non-main branch. After that, the main branch resumes ' ...
    '(blue color) for all values greater than zero. \n'])

%% QUESTION 6

%{
    Part a) Using MATLAB function 'roots':
    The roots function solves polynomial equations of the form:
        p1(x^n) +...+ pn(x) + pn+1=0. 
    Polynomial equations contain a single variable with nonnegative 
    exponents.
%}

% Defining coefficients on the necessary format the function needs
coef = [0.01, 1000, 0.01];

% Using the MATLAB function
roots_r1 = roots(coef);

% Selection the largest root approximation
r1 = max(roots_r1);

% Displaying results
fprintf('Estimated root for r1: x = %.15f\n', r1);

%{
    Part b) Using Newton Method:
    Newton's method sucess depends on the initial choice of x0 and may not 
    converge if the initial guess is far from the root.
%}

% Defining the given polynomial function and its derivative
f = @(x) 0.01*x.^2 + 1000*x + 0.01;
df = @(x) 0.02*x + 1000;

% Initial guess, given the first result
x0 = 0.0001; 

% Given by hypothesis, defining tolerance
tol = eps; 

% Given by some last excercise, defining iterations
maxiter = 20; 

% Call the newton function to find the root
[r2, ~, ~] = newton(f, df, x0, maxiter, tol);

% Displaying results
fprintf('Estimated root for r2: x = %.15f\n', r2);

%{
    Part c) Using quadratic formula:
    The quadratic formula helps us solve any quadratic equation. First, 
    we bring the equation to the form ax² + bx + c=0, where a, b, and c are 
    coefficients. Then, we plug these coefficients in the formula: 
        (-b±√(b²-4ac))/(2a) 
%}

% Defining coefficients
a = 0.01;
b = 1000;
c = 0.01;

% By formula, defining discriminant
discriminant = b^2 - 4*a*c;

% Obtaining root
r3 = (-b + sqrt(discriminant)) / (2*a);

% Displaying results
fprintf('Estimated root for r3: x = %.15f\n', r3);

%{
    Part d) Commenting results.
%}

% Displaying comments
fprintf(['Additional comments: First of all, in order to observe the change ' ...
    'between using one method or the other, we have to display the answer ' ...
    'to approximately 15 decimal places. By observing and analyzing the ' ...
    'result, we can see that both the use of the Matlab function "roots" ' ...
    'and the use of Newtons method have an identical magnitude when ' ...
    'displayed to 15 decimal places. This shows the accuracy of Newtons ' ...
    'algorithm for finding roots. On the other hand, we can see that when ' ...
    'using the quadratic formula, the result changes by several decimal ' ...
    'places. In other words, it is not as accurate as the first two methods ' ...
    'used in this exercise. \n']);

%% QUESTION 7

%{
    COMMENTS:
        - The constraint may be the equation that describes the boundary 
        of a region or it may not be.
        - Need to be careful with the fact that in some cases minimums and 
        maximums won't exist even though the method will seem to imply 
        that they do.
%}

%{
    EXCERCISE DIVISION:
        Part a) Finding minimum and maximum
        Part b) Checking graphically that its correct
%}

%{
    PART A) Finding minimum and maximum
%}

% Cleaning
clear all, close all;

% Defining the Lagrangian function
L = @(x) x(1).^3 + x(2).^3 + 3*x(1)*x(1) + x(3)*((x(1) - 3).^2 + (x(2) - 3).^2 - 9);

% Defining Lagrange multipliers system
f = @(x) [3*x(1).^2 + 3*x(2) + 2*x(3)*(x(1) - 3), 3*x(2).^2 + 3*x(1) + 2*x(3)*(x(2) - 3), (x(1) - 3).^2 + (x(2) - 3).^2 - 9];

% Defining equations derivatives
df = @(x) [6*x(1) + 2*x(3), 3, 2*(x(1) - 3); 3, 6*x(2) + 2*x(3), 2*(x(2) - 3); 2*(x(1) - 3), 2*(x(2) - 3), 0];

% Defining initial guess
init_guess = [0; 0; 0];

% Defining maximum number of iterations
maxiter = 100;

% Defining tolerance 
tol = eps;

% Newton function for the critical points
[x_crit, ~, ~] = newton(f, df, init_guess, maxiter, tol);

% Displaying critical points
fprintf('Critical point: [ x = %.5f , y = %.5f ] \n', x_crit(1), x_crit(2));

% Evaluating the objective function on critical point
xtrem_val = x_crit(1).^3 + x_crit(2).^3 + 3 * x_crit(1) * x_crit(2);

% Displaying extreme value
fprintf('Extreme Value: %.5f \n', xtrem_val)

%{
    PART B) Checking graphically that is correct
%}

% Defining plot
figure;

% Defining a range of x-values 
x1 = -4:0.4:4;

% Defining a range of y-values equal to x-values
y1 = x1;

% Meshgrid fos the matrix needed fot plotting
[X1,Y1] = meshgrid(x1);

% Calculating the corresponding z-values of F(x,y)
Z1 = X1.^3 + Y1.^3 + 3*X1.*Y1;

% Creating a 3D-plot of F
meshz(Z1);

%{
    Adding constraint figure
%}

% Defining a range of x-values 
x2 = 0:0.50:7;

% Defining a range of y-values equal to x-values
y2 = x2;

% Calculating the corresponding z-values of F(x,y)
z2 = (x2 - 3).^2 - (y2 - 3).^2 - 9;

% Adding a 3D-plot of the constraint
hold on;
plot3(x2, y2, z2,'-o', 'Color', 'r');

% Labeling the axes 
xlabel('x');
ylabel('y');
zlabel('z');

% Adding colorbar
colorbar;

% Adding a title
title('Plot of F(x, y) with constraint');

% Adding grig to the figure
grid on;

%{
    Adding critical point
%}

% Plot the critical point
scatter3(x_crit(1), x_crit(2), xtrem_val, 'Marker', 'o', 'Color', 'g', 'LineWidth', 2);

% Adding legend 
legend('F(x, y)', 'constraint', 'Critical point');

% Displaying comments
fprintf(['The results obtained and the results observed in the graph seem ' ...
    'correct. It was a great learning experience to observe how ' ...
    'using a method to find roots, such as Newtons method, of a certain ' ...
    'function, can be used to find critical points. One disadvantage, ' ...
    'which I realized in this excercise, is that a near local maxima or ' ...
    'local minima, due to oscillation, may cause to a slow ' ...
    'convergence.\n']);

%% QUESTION 8

%{
    COMMENTS:
        - Fast convergence: It converges fast, if it converges. Which 
        means, in most cases we get root (answer) in less number of steps.
        - It requires only one guess.
        - Derivation is more intuitive, which means it is easier to 
        understand its behaviour, when it is likely to converge and when 
        it is likely to diverge.
        
%}

%{
    EXCERCISE DIVISION:
        Part a) Calculating
        Part b) Plotting
%}

%{
    PART A) Calculating
%}

% Cleaning
clear all, close all;

% Defining the function g(x)
g = @(x) 4*x - 4*x.^2;

% Generating 1000 uniformly spaced in the interval [-0.1, 1]
interval = linspace(-0.1, 1, 1000);

% Defining number of maxmum iterations
max_iterations = 100;

% Defining tolerance 
tol = 1e-6;

% Initializing array to store roots 
con_roots = zeros(1000, 1);

% Defining the roots values
r1 = 0.45; 
r2 = 0.65; 
r3 = 0.3; 
r4 = 0.9; 

% Defining r^ array
roots = [r1, r2, r3, r4]; 

% Creating arrays to store legend entries
ent = cell(length(roots), 1);

% Creating arrays to store legend handles
hand = zeros(length(roots), 1);

% Iterating points
for i = 1:1000
    x0 = interval(i);
    
    % Applying Newton's method at each point
    [x, iterates, residuals] = newton(@(x)g(x) - x0, @(x) 4 - 8 * x, x0, max_iterations, tol);
    
    % Checking convergence
    if abs(g(x) - x0) < tol

        % Determining root that converged
        [~, index] = min(abs(x - roots));
        con_roots(i) = index;

    end

end

%{
    PART B) Plotting
%}

% Creating colormap array
colors = ['g', 'c', 'm', 'y'];

% Ploting 
for i = 1:1000
    if con_roots(i) > 0

        % Ploting each interval point
        plot(interval(i), 0, '.', 'Color', colors(con_roots(i)));
        hold on;

    end

end

% Customizing plot 
% Customizing x-label
xlabel('Interval [ -0.1, 1]');

% Customizing y-label
ylabel('Number of Iterations');

% Adding title
title(['Convergence of the 1000 uniformly spaced points on the interval ' ...
    '[-0.1, 1] with Newtons Method']);

% Updating legend entries and handles
for i = 1:length(roots)
    
    % Displaying legend entries
    ent{i} = sprintf('Root %d', i);

    % Plotting legend handles
    hand(i) = plot(NaN, NaN, 'o', 'Color', colors(i)); % Create empty plot for legend

end

% Creating the legend
legend(hand, ent);

% Putting grid
grid on;

% Displaying results
fprintf('Counts of points converging to each root:\n');

% Displaying for each root
for i = 1:length(roots)
    
    % Displaying each x amount of points converged to root x
    fprintf('Root %d: %d points\n', i, sum(con_roots == i));

end

% Displaying comments
fprintf(['Newtons method always converges to the root nearest the initial ' ...
    'condition: From the plot, we can observe that this claim is generally ' ...
    'true. Points tend to converge to the root nearest their initial ' ...
    'condition.\n']);
fprintf(['Each of the four roots attracts the same number of ' ...
    'iterations.\n']);

##### SOURCE END #####
--></body></html>