
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-09-26"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% Main Script</span>
</pre><p>QUESTION 2: approximate sin(1) using only 3 term of its Taylor series by calling your sin_taylor function. Give an estimate of the error using the built-in sin function.</p><pre class="codeinput">my_fun = sin_taylor(1,3);
built_in = sin(1);

estimate_error = abs(my_fun-built_in);
</pre><p>QUESTION 3: Estimate the error for the Taylor approximation of sin(1) for n = 1, . . . , 41. Plot the error versus n using MATLAB%s built-in loglog command. Approximately how many terms are necessary to obtain error less than 10&#8722;5 ? What about error less than 10&#8722;15? Comment your results.</p><pre class="codeinput"><span class="comment">% COMMENT: For this particular exercise, I will modify my function</span>
<span class="comment">% and put it in another script so I can calculate the error.</span>

<span class="comment">% ANSWERS: 34 terms to obtain an error less than 10^-5.</span>
ers = sin_taylor2(1,41);
nv=1:41;
loglog(nv, ers, <span class="string">'-o'</span>);
xlabel(<span class="string">'Number of n'</span>);
ylabel(<span class="string">'Error'</span>);
title(<span class="string">'Taylor approximation error sin(1)'</span>);
grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <pre class="codeinput"><span class="comment">% QUESTION 4: Approximate sin(10&#960;) using a Taylor approximation of</span>
<span class="comment">% order n = 1, . . . , 41. Plot the error versus n using Matlab s</span>
<span class="comment">% built-in loglog command. Comment your results.</span>

<span class="comment">% COMMENT: It seems to have a very similar behavior to the previous</span>
<span class="comment">% exercise.</span>
ers2 = sin_taylor2(10*pi,41);
nv2=1:41;
loglog(nv2, ers2, <span class="string">'-o'</span>);
xlabel(<span class="string">'Number of n'</span>);
ylabel(<span class="string">'Error'</span>);
title(<span class="string">'Taylor approximation error sin(10&#960;)'</span>);
grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <pre class="codeinput"><span class="comment">% QUESTION 5:  Produce a graph of sin x for x &#8712; [&#8722;&#960;, &#960;] using Matlab&#8217;s</span>
<span class="comment">% in-built function sin. On the same plot, superimpose graphs of Pn(x),</span>
<span class="comment">% for n = 1, 3, 5, 7, 9, where Pn is the approximating Taylor polynomial</span>
<span class="comment">% of order n. Comment your results</span>

<span class="comment">% COMMENT: For this particular exercise, I will modify my function</span>
<span class="comment">% and put it in another script so I will be able to plot Pn(x)s.</span>

<span class="comment">% STEP 1: Plot sin(x)</span>
close <span class="string">all</span>;
hold <span class="string">on</span>;

x = linspace(-pi, pi, 100);
sin_x = sin(x);
plot(x, sin_x, <span class="string">'r'</span>)

<span class="comment">% STEP 2: Plot graphs of Pn(x) for n = 1, 3, 5, 7, 9</span>
n_order = [1, 3, 5, 7, 9];
colors = [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'g'</span>, <span class="string">'k'</span>, <span class="string">'m'</span>];
<span class="keyword">for</span> i = 1:length(n_order)
    n = n_order(i);
    color = colors(i);
    plot(x, sin_taylor3(x, n) , color);
<span class="keyword">end</span>

hold <span class="string">off</span>;

<span class="comment">% STEP 3: Add labels, title and legend</span>
xlabel(<span class="string">'x'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Sin(x) and Taylor Polynomial approximations'</span>);
legend(<span class="string">'sin(x)'</span>, <span class="string">'p1(x)'</span>, <span class="string">'p3(x)'</span>, <span class="string">'p5(x)'</span>, <span class="string">'p7(x)'</span>, <span class="string">'p9(x)'</span>);
grid <span class="string">on</span>;

hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <p>QUESTION 6: Use a Taylor expansion of sin to prove the error bound <tt>sin(1) &#8722; 0.8416</tt> &lt; 1/7!. Generalize this result to prove an error bound for <tt>sin(x) &#8722; Pn(x)</tt> x &#8712; R, n &#8712; N.</p><pre class="codeinput"><span class="comment">% COMMENT: for this exercise i will use my original sin taylor expansion.In</span>
<span class="comment">% other words the sin_taylor function on sin_taylor script.</span>

<span class="comment">% We know that...</span>
k = 1/factorial(7);
<span class="comment">% With the taylor expasion of sin... we know that...</span>
sin_1 = sin_taylor(1, 3);
constant = 0.8416666666666666666666;
<span class="comment">% So..</span>
<span class="keyword">if</span> abs(sin_1 - constant) &lt; k
    disp(<span class="string">'TRUE'</span>);
<span class="keyword">else</span>
    disp(<span class="string">'FALSE'</span>);
<span class="keyword">end</span>
<span class="comment">% Proof:</span>
<span class="comment">% We know that Taylor expansion has this formula:</span>
<span class="comment">% (-1^n)(x^(2n+1)) / (2n+1)!.</span>
<span class="comment">% By hypothesis of this problem, we know that the denominator is 7!,</span>
<span class="comment">% hence that:</span>
<span class="comment">% 7 = (2n+1) -&gt; n=3. Now, we can say that P3(x), in other words of order 3.</span>
<span class="comment">% We can see that it depends on n.</span>
<span class="comment">% Lets continue...</span>
<span class="comment">% (-1^3)(1^(2(3)+1)) / (2(3)+1)! = (-1)(1) / 7! = -1/7!</span>
<span class="comment">% We can see in the row above that there is a pattern to this...</span>
<span class="comment">% So the generalize error bound will be:</span>
<span class="comment">%  | (-1^n)(x^(2n+1)) / (2n+1)! | = abs( (-1^n)(x^(2n+1)) / (2n+1)! ).</span>
</pre><pre class="codeoutput">TRUE
</pre><p>QUESTION 7:  Consider a modification of the bisection algorithm which iteratively trisects the interval at each step instead of bisecting it. Describe this algorithm in pseudocode and prove that given a, b, f such that f : [a, b] &#8594; R is continuous and sgn(f(a)) &#824;= sgn(f(b)), the algorithm is guaranteed to converge to a root of f.</p><pre class="codeinput"><span class="comment">% DESCRIPTION:</span>
<span class="comment">% 1. Each iteration lets divide the interval [a,b] into three equal</span>
<span class="comment">% subintervals, instead of two as the Bisection does. This subintervals</span>
<span class="comment">% are:  subinterval 1: [a, (2a + b) / 3],</span>
<span class="comment">%       subinterval 2: [(2a + b) / 3, (a + 2b) / 3]</span>
<span class="comment">%       subinterval 3: [(a + 2b) / 3, b]</span>
<span class="comment">% 2. Evaluate the function at the end points of each subinterval made in</span>
<span class="comment">% the STEP 1.</span>
<span class="comment">% 3. If any of these values are close to zero, we have found</span>
<span class="comment">% an approximate root. Otherwise, continue to STEP 4.</span>
<span class="comment">% 4. If any of these values are close to zero, lets take the subinterval</span>
<span class="comment">% with the smallest absolute value (calculated in STEP 2) and divide into</span>
<span class="comment">% three more equal subintervals.</span>
<span class="comment">% 5. Repeat until you find the approximate root or until you reach</span>
<span class="comment">% the maximum number of iterations.</span>

<span class="comment">% Proof arguments:</span>
<span class="comment">% - The interval [a,b] is repeatedly trisected and the subinterval that</span>
<span class="comment">% contains the root is becoming more refined with each iteration.</span>
<span class="comment">% - The subinterval will converge to a single point. This is because the</span>
<span class="comment">% subinterval will become smaller and smaller with each 3-segmentation</span>
<span class="comment">% made according to the increase in iterations.</span>
<span class="comment">% - Once the subinterval size becomes smaller than the specified tolerance</span>
<span class="comment">% x, the output of the algorithm is the midpoint of the final subinterval.</span>
<span class="comment">% This point we called the root of f.</span>
</pre><p>QUESTION 9: Showcase your trisection algorithm in main.m. Specifically, make suitable function calls to demonstrate that it has the required properties. Demonstrate how it can be used to solve the equation x = cos(x). Comment your results.</p><pre class="codeinput"><span class="comment">% Trisection algorithm</span>
syms <span class="string">x</span>

<span class="comment">% Example 1</span>
f = 5*x^3-2*x+16;
a = -1;
b = -2;
num_iter = 100;
epsilon = 0.00001;
root = trisection(f, a, b, epsilon, num_iter);

<span class="comment">% Example 2</span>
g = x^2 + 4*x - 6;
c = -5;
d = -6;
num_iter = 100;
epsilon = 0.00001;
root2 = trisection(g, c, d, epsilon, num_iter);
</pre><p>QUESTION 10: Decide which algorithm is better between the bisection and trisection algorithms. Explain and justify your answer.</p><pre class="codeinput"><span class="comment">% I consider that the best algorithm is bisection because it requires</span>
<span class="comment">% fewer iterations because it divides the interval fewer times and</span>
<span class="comment">% actually requires fewer partitions to converge on the desired root.</span>

<span class="comment">% Likewise, it allows for lower algorithmic complexity and, therefore,</span>
<span class="comment">% lower computational cost.</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
% Main Script

%%
% QUESTION 2: approximate sin(1) using only 3 term of 
% its Taylor series by calling your sin_taylor function. 
% Give an estimate of the error using the built-in sin function.
my_fun = sin_taylor(1,3); 
built_in = sin(1);

estimate_error = abs(my_fun-built_in);

%%
% QUESTION 3: Estimate the error for the Taylor approximation of 
% sin(1) for n = 1, . . . , 41. Plot the error versus n using 
% MATLAB%s built-in loglog command. Approximately how many terms 
% are necessary to obtain error less than 10−5 ? What about error 
% less than 10−15? Comment your results.

% COMMENT: For this particular exercise, I will modify my function 
% and put it in another script so I can calculate the error.

% ANSWERS: 34 terms to obtain an error less than 10^-5.
ers = sin_taylor2(1,41);
nv=1:41;
loglog(nv, ers, '-o');
xlabel('Number of n');
ylabel('Error');
title('Taylor approximation error sin(1)');
grid on;

%%

% QUESTION 4: Approximate sin(10π) using a Taylor approximation of 
% order n = 1, . . . , 41. Plot the error versus n using Matlab s 
% built-in loglog command. Comment your results.

% COMMENT: It seems to have a very similar behavior to the previous 
% exercise.
ers2 = sin_taylor2(10*pi,41);
nv2=1:41;
loglog(nv2, ers2, '-o');
xlabel('Number of n');
ylabel('Error');
title('Taylor approximation error sin(10π)');
grid on;


%%

% QUESTION 5:  Produce a graph of sin x for x ∈ [−π, π] using Matlab’s 
% in-built function sin. On the same plot, superimpose graphs of Pn(x), 
% for n = 1, 3, 5, 7, 9, where Pn is the approximating Taylor polynomial 
% of order n. Comment your results

% COMMENT: For this particular exercise, I will modify my function 
% and put it in another script so I will be able to plot Pn(x)s.

% STEP 1: Plot sin(x) 
close all;
hold on;

x = linspace(-pi, pi, 100);
sin_x = sin(x);
plot(x, sin_x, 'r')

% STEP 2: Plot graphs of Pn(x) for n = 1, 3, 5, 7, 9
n_order = [1, 3, 5, 7, 9];
colors = ['b', 'c', 'g', 'k', 'm'];
for i = 1:length(n_order)
    n = n_order(i);
    color = colors(i);
    plot(x, sin_taylor3(x, n) , color);
end

hold off;

% STEP 3: Add labels, title and legend
xlabel('x');
ylabel('y');
title('Sin(x) and Taylor Polynomial approximations');
legend('sin(x)', 'p1(x)', 'p3(x)', 'p5(x)', 'p7(x)', 'p9(x)');
grid on;

hold off;


%%
% QUESTION 6: Use a Taylor expansion of sin to prove the error bound
% |sin(1) − 0.8416| < 1/7!. Generalize this result to prove an error 
% bound for |sin(x) − Pn(x)| x ∈ R, n ∈ N.

% COMMENT: for this exercise i will use my original sin taylor expansion.In
% other words the sin_taylor function on sin_taylor script.

% We know that...
k = 1/factorial(7);
% With the taylor expasion of sin... we know that...
sin_1 = sin_taylor(1, 3);
constant = 0.8416666666666666666666;
% So..
if abs(sin_1 - constant) < k
    disp('TRUE');
else 
    disp('FALSE');
end
% Proof:
% We know that Taylor expansion has this formula:
% (-1^n)(x^(2n+1)) / (2n+1)!.
% By hypothesis of this problem, we know that the denominator is 7!,
% hence that:
% 7 = (2n+1) -> n=3. Now, we can say that P3(x), in other words of order 3.
% We can see that it depends on n.
% Lets continue...
% (-1^3)(1^(2(3)+1)) / (2(3)+1)! = (-1)(1) / 7! = -1/7!
% We can see in the row above that there is a pattern to this...
% So the generalize error bound will be: 
%  | (-1^n)(x^(2n+1)) / (2n+1)! | = abs( (-1^n)(x^(2n+1)) / (2n+1)! ).


%%
% QUESTION 7:  Consider a modification of the bisection algorithm which 
% iteratively trisects the interval at each step instead of bisecting it. 
% Describe this algorithm in pseudocode and prove that given a, b, f such 
% that f : [a, b] → R is continuous and sgn(f(a)) ̸= sgn(f(b)), the 
% algorithm is guaranteed to converge to a root of f.

% DESCRIPTION:
% 1. Each iteration lets divide the interval [a,b] into three equal 
% subintervals, instead of two as the Bisection does. This subintervals
% are:  subinterval 1: [a, (2a + b) / 3], 
%       subinterval 2: [(2a + b) / 3, (a + 2b) / 3]
%       subinterval 3: [(a + 2b) / 3, b]
% 2. Evaluate the function at the end points of each subinterval made in
% the STEP 1.
% 3. If any of these values are close to zero, we have found 
% an approximate root. Otherwise, continue to STEP 4.
% 4. If any of these values are close to zero, lets take the subinterval
% with the smallest absolute value (calculated in STEP 2) and divide into 
% three more equal subintervals.
% 5. Repeat until you find the approximate root or until you reach 
% the maximum number of iterations.

% Proof arguments:
% - The interval [a,b] is repeatedly trisected and the subinterval that
% contains the root is becoming more refined with each iteration.
% - The subinterval will converge to a single point. This is because the
% subinterval will become smaller and smaller with each 3-segmentation 
% made according to the increase in iterations.
% - Once the subinterval size becomes smaller than the specified tolerance
% x, the output of the algorithm is the midpoint of the final subinterval.
% This point we called the root of f.
 

%%
% QUESTION 9: Showcase your trisection algorithm in main.m. Specifically, 
% make suitable function calls to demonstrate that it has the required 
% properties. Demonstrate how it can be used to solve the equation 
% x = cos(x). Comment your results.

% Trisection algorithm 
syms x

% Example 1
f = 5*x^3-2*x+16;
a = -1;
b = -2;
num_iter = 100;
epsilon = 0.00001;
root = trisection(f, a, b, epsilon, num_iter);

% Example 2
g = x^2 + 4*x - 6;
c = -5;
d = -6;
num_iter = 100;
epsilon = 0.00001;
root2 = trisection(g, c, d, epsilon, num_iter);

%%
% QUESTION 10: Decide which algorithm is better between the bisection 
% and trisection algorithms. Explain and justify your answer.

% I consider that the best algorithm is bisection because it requires 
% fewer iterations because it divides the interval fewer times and 
% actually requires fewer partitions to converge on the desired root.

% Likewise, it allows for lower algorithmic complexity and, therefore, 
% lower computational cost.


##### SOURCE END #####
--></body></html>